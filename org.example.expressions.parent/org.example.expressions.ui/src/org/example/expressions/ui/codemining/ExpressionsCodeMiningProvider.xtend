/*
 * generated by Xtext 2.14.0
 */
package org.example.expressions.ui.codemining

import org.eclipse.jface.text.BadLocationException
import org.eclipse.jface.text.IDocument
import org.eclipse.jface.text.codemining.ICodeMining
import org.eclipse.xtext.resource.XtextResource
import org.eclipse.xtext.ui.codemining.AbstractXtextCodeMiningProvider
import org.eclipse.xtext.util.CancelIndicator
import org.eclipse.xtext.util.IAcceptor
import org.eclipse.xtext.EcoreUtil2
import org.example.expressions.expressions.Variable
import com.google.inject.Inject
import org.example.expressions.typing.ExpressionsTypeSystem
import org.example.expressions.services.ExpressionsGrammarAccess
import org.eclipse.xtext.nodemodel.util.NodeModelUtils

class ExpressionsCodeMiningProvider extends AbstractXtextCodeMiningProvider {

	@Inject ExpressionsGrammarAccess grammar
	@Inject extension ExpressionsTypeSystem

	override void createCodeMinings(IDocument document, XtextResource resource, CancelIndicator indicator,
		IAcceptor<? super ICodeMining> acceptor) throws BadLocationException {

		// get all variable declarations
		val variables = EcoreUtil2.eAllOfType(resource.getContents().get(0), Variable)
		// get grammar element for variable's name
		val nameElement = grammar.variableAccess.nameIDTerminalRuleCall_1_0

		for (variable : variables) {
			val type = variable.expression.inferredType
			if (type !== null) {
				// find document offset for inline annotation
				val node = NodeModelUtils.findActualNodeFor(variable);
				val nameNode = node.asTreeIterable.findFirst[grammarElement == nameElement]
				if (nameNode !== null) {
					// create line content code mining for inline annotation before grammarElement 'var'
					val annotationText = " : " + type
					acceptor.accept(createNewLineContentCodeMining(nameNode.getTotalOffset() + 1, annotationText));
				}
			}
		}
	}
}
